<!DOCTYPE html><html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><!--replace-start-0--><!--replace-start-5--><!--replace-start-8--><title>An approach to MTL style Haskell - My Zettelkasten</title><!--replace-end-8--><!--replace-end-5--><!--replace-end-0--><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Libre Franklin", serif !important}body .ui.container{font-family:"Libre Franklin", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Merriweather", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body .q.under > li > span.zettel-link-container span.zettel-link a{color:#808080 !important}body .q.unmatched{display:none}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-teal nav.bottomPane{background-color:rgba(0,181,173,2.0e-2)}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-brown nav.bottomPane{background-color:rgba(165,103,63,2.0e-2)}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-red nav.bottomPane{background-color:rgba(219,40,40,2.0e-2)}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-orange nav.bottomPane{background-color:rgba(242,113,28,2.0e-2)}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-yellow nav.bottomPane{background-color:rgba(251,189,8,2.0e-2)}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-olive nav.bottomPane{background-color:rgba(181,204,24,2.0e-2)}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-green nav.bottomPane{background-color:rgba(33,186,69,2.0e-2)}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-blue nav.bottomPane{background-color:rgba(33,133,208,2.0e-2)}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-violet nav.bottomPane{background-color:rgba(100,53,201,2.0e-2)}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-purple nav.bottomPane{background-color:rgba(163,51,200,2.0e-2)}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-pink nav.bottomPane{background-color:rgba(224,57,151,2.0e-2)}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-grey nav.bottomPane{background-color:rgba(118,118,118,2.0e-2)}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body div#neuron-theme-default-black nav.bottomPane{background-color:rgba(27,28,29,2.0e-2)}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.94999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.container.universe{padding-top:1em}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.bottomPane ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body nav.bottomPane ul.context-list > li{list-style-type:lower-roman}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Merriweather|Libre+Franklin|Roboto+Mono&amp;display=swap" rel="stylesheet" /><!--replace-start-1--><!--replace-start-4--><!--replace-start-7--><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><meta content="See the related gist" name="description" /><meta content="An approach to MTL style Haskell" property="og:title" /><meta content="My Zettelkasten" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}</style><!--replace-end-7--><!--replace-end-4--><!--replace-end-1--><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container universe" id="neuron-theme-default-teal"><!--replace-start-2--><!--replace-start-3--><!--replace-start-6--><div class="ui text container" id="zettel-container" style="position: relative"><div class="zettel-view"><article class="ui raised attached segment zettel-content"><div class="pandoc"><h1 id="an-approach-to-mtl-style-haskell">An approach to MTL style Haskell</h1><p><em>See the related <a href="https://gist.github.com/fieldstrength/8d53858264bc8af59d2d2690b425b538">gist</a></em></p><h2 id="introduction">Introduction</h2><p><em>MTL style</em> is an approach to modeling effects in <span class="zettel-link-container cf"><span class="zettel-link"><a href="haskell.html">Haskell</a></span></span> that was popularized by Edward Kmett’s <a href="https://hackage.haskell.org/package/mtl">mtl library</a>. What started as a very general technique turns out to be highly useful as a primary overall structure for your application. And while this technique has competitors, like libraries for algebraic effects such as Polysemy or Fused Effects, this style remains extremely compelling on the merits, and is also especially easy to understand as it uses only well-established Haskell concepts.</p><p>I want to lay out my approach for the benefit of anyone who needs such a template, and to show just how powerful it can be. A new variation I’ve developed during my work at Klarna seems to me to be the best iteration yet. So let me make the case for this “MTL-style application structure”.</p><p>In order to motivate this style, I’ll describe two of the other approaches we went through to arrive here before getting to the preferred solution.</p><ul><li>First, the tried-and-true <em>low-tech</em> approach. Works well and easy to learn, but at the expense of repetition and lack of code re-use.</li><li>Next the <em>transformer stack</em> approach, which achieves nice separation of concerns and code reuse at the expense of high incidental complexity, high barrier-to-entry, and some extra risk of bugs.</li><li>Finally, a <em>deriving-based</em> approach that pretty much has all of the advantages and none of the disadvantages of the above.</li></ul><h2 id="goals-and-motivation">Goals and motivation</h2><ul><li>As a group of multiple Haskell teams in a monorepo, we want an efficient way for each team to re-use the work of the others. A new integration library should easily “plug in” to any other team’s code. We want composable “lego pieces”.</li><li>We need to be able to onboard new engineers to our repo without unreasonable intimidation or learning requirements.</li><li>Adding a new feature in a fully idiomatic and tested way should not bottleneck on involvement of senior Haskell engineers.</li><li>Even so, we also don’t want to lose out on the great properties of haskell, which do give us huge value in terms of safety and developer efficiency. In other words, we don’t believe insisting on “boring Haskell” is always the right tradeoff, but we do insist that advanced features are used with great care and consideration, consistent with the above goals.</li></ul><h2 id="what-is-mtl-style">What is MTL style</h2><p>The essence of MTL style for applications is:</p><ul><li>Every business logic function has a typeclass constraint for each <em>effect</em> that it needs to perform to do its job, like sending an event or checking a database. The signature of these functions furthermore do not allow unrestricted <code>IO</code>.</li><li>These typeclass constraints are discharged at, or close to, the <code>main</code> entrypoint for the application where you specify which <span class="zettel-link-container cf"><span class="zettel-link"><a href="monad.html">monad</a></span></span>, i.e. which <span class="zettel-link-container cf"><span class="zettel-link"><a href="computational-context.html">computational context</a></span></span> should be used to describe your app. Usually you enter this monad from your <code>main</code> as soon as all the resources needed for its environment have been set up. The monad should pretty much always be something <em>equivalent</em> to <code>ReaderT env IO</code>. See <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/">Michael Snoyman’s explanation</a> as to why sticking with this form is desirable.</li><li>These same business logic functions are then also tested within a different monad that achieves mocking by using a different instance of those type classes.</li></ul><p>Every structure I’ll describe here fits this general mold. They only differ in the way they define data types and type class instances to do so.</p><h2 id="cataloging-the-variations-of-the-style">Cataloging the variations of the style</h2><p>Lets start by laying out an example typeclass interface. We’ll implement this interface with each of the methods we discussion.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">Document</span>
<span class="kw">data</span><span class=""> </span><span class="dt">DocId</span>

<span class="kw">class</span><span class=""> </span><span class="dt">Monad</span><span class=""> m </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> m </span><span class="kw">where</span>
<span class="ot">  persistDocument ::</span><span class=""> </span><span class="dt">DocId</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Document</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> m ()</span>
<span class="ot">  getDocument ::</span><span class=""> </span><span class="dt">DocId</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> m (</span><span class="dt">Maybe</span><span class=""> </span><span class="dt">Document</span><span class="">)</span>
</code></pre></div><h3 id="the-basic-low-tech-approach">The basic low-tech approach</h3><p>This first solution is the absolute simplest approach to this style that is worth considering.</p><p>I mention it first not only because it forms the bases for our preferred solution, but you should understand how this simple approach works before trying anything else. For that reason, this may be the right fit for i.e. a team completely new to Haskell.</p><p>In essence, with this approach you:</p><ul><li>Define a <strong>concrete, named</strong> monad for your application, with shape <code>Env -&gt; IO a</code>.</li><li>Define a <strong>concrete, named</strong> monad for your tests.</li><li>You manually provide the instances for those monads.</li></ul><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">newtype</span><span class=""> </span><span class="dt">RealApp</span><span class=""> a  </span><span class="co">-- instance Monad RealApp</span>
<span class="kw">newtype</span><span class=""> </span><span class="dt">Test</span><span class=""> a     </span><span class="co">-- instance Monad Test</span>

<span class="ot">runRealApp ::</span><span class=""> </span><span class="dt">AppConfig</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">RealApp</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">IO</span><span class=""> a</span>
<span class="ot">runTest ::</span><span class=""> </span><span class="dt">TestConfig</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Test</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> a</span>

<span class="kw">instance</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> </span><span class="dt">RealApp</span><span class=""> </span><span class="kw">where</span>
<span class="">  persistDocument docId doc </span><span class="ot">=</span><span class=""> </span><span class="op">...</span>
<span class="">  getDocument docId </span><span class="ot">=</span><span class=""> </span><span class="op">...</span>

<span class="kw">instance</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> </span><span class="dt">Test</span><span class=""> </span><span class="kw">where</span>
<span class="">  persistDocument docId doc </span><span class="ot">=</span><span class=""> </span><span class="op">...</span>
<span class="">  getDocument docId </span><span class="ot">=</span><span class=""> </span><span class="op">...</span>
</code></pre></div><p>BENEFITS</p><ul><li>Simple, easy, lowest-barrier to entry</li><li>You can step up to our better solution bit-by-bit as you get comfortable with it</li></ul><p>DRAWBACKS</p><ul><li>Write much more instance code; repeat yourself a lot. Especially if you are multiple Haskell teams.</li></ul><h3 id="a-disfavored-approach-run-everything-in-a-big-trasformer-stack">A disfavored approach: Run everything in a big trasformer stack</h3><p>This method introduces some very desirable properties that are worth preserving, in terms of decoupling and compositionality. But in the end, it also introduces a lot of costs and difficulties. And as we’ll show in the next section, those costs are not actually needed to get the same benefits.</p><p>The defining properties of this approach are:</p><ul><li>Each effect typeclass gets<ul><li>A monad transformer that carries the production implementation</li><li>A monad transformer that carries the test implementation</li></ul></li><li>Instead of working in an explicitly defined monad, the application and the tests each run in a large stack of many monad transformers.</li></ul><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">newtype</span><span class=""> </span><span class="dt">RealPersistDocumentT</span><span class=""> m</span><span class="ot"> a ::</span><span class=""> </span><span class="dt">RealPersitDocumentT</span><span class=""> (</span><span class="dt">ReaderT</span><span class=""> </span><span class="dt">ConnectionPool</span><span class=""> (m a))</span>

<span class="ot">runRealPersistDocumentT ::</span><span class=""> </span><span class="dt">ConnectionPool</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">RealPersistDocumentT</span><span class=""> m a </span><span class="ot">-&gt;</span><span class=""> m a</span>

<span class="kw">instance</span><span class=""> </span><span class="dt">MonadIO</span><span class=""> m </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> (</span><span class="dt">RealPersistDocumentT</span><span class=""> m a) </span><span class="kw">where</span>
<span class="">  </span><span class="op">...</span>

<span class="kw">instance</span><span class=""> </span><span class="ot">{-# OVERLAPPABLE #-}</span><span class=""> (</span><span class="dt">MonadTrans</span><span class=""> t, </span><span class="dt">Monad</span><span class=""> (t m), </span><span class="dt">MonadPersistDocument</span><span class=""> m) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> (t m) </span><span class="kw">where</span>
<span class="">  getDocument docId </span><span class="ot">=</span><span class=""> lift </span><span class="op">$</span><span class=""> getDocument docId</span>
<span class="">  persistDocument docId doc </span><span class="ot">=</span><span class=""> lift </span><span class="op">$</span><span class=""> persistDocument docId doc</span>
</code></pre></div><p>The whole approach works because that last “pass through instance” ensures that when a new transformer is added to your stack, the whole stack will still have an instance as long as the transformers all implement <code>MonadTrans</code>.</p><p>What is shown here is actually the ideal case. In some cases (when any of the type class methods take a monadic computation in negaitve position) you need to use <code>MonadTransControl</code>, instead of the much simpler <code>MonadTrans</code>. And this requirement is not associated with any practical benefit in our style of use.</p><p>BENEFITS</p><ul><li>Separation of concerns. The “library author” defining the interface for the effect can also describe the anticipated real/test implementations in a generic way. This means that one dev from one team can implement a library to interface with a particular system, and any other team can easily plug it in to their application. If you want to swap out one implementation in their monad for another one it can be quite easy, you just switch out the corresponding <code>run</code> natural transformation function at the point where you enter your monad.</li></ul><p>DOWNSIDES</p><ul><li>Mess. The fact that there is no named monad, and no single <code>run</code> function, means that over time these run functions tend to get spread out over different regions of code. This makes it difficult at any one place to see which monad you may be in. It leads to an explosion of different variations of different monads that may be active at different points.</li><li>Loss of easy control over a critical piece of code; the function that takes your transformer stack to <code>IO</code>. This is a function its extremely important to see clearly, because it affects how your entire application runs. Certain things just do not belong in it; they should be <span class="zettel-link-container cf"><span class="zettel-link" title="2021-03-21"><a href="natural-transformation.html">natural transformation</a></span></span>s only. Yet because in the transformer approach this function is the composition of a large number of individual functions that are defined in individual libraries, its far too easy for undesirable behavior to sneak in unnoticed. And in fact we have encountered one such example of this, where a broken library implementation took down an important endpoint that <em>did not even use the library in question</em>.</li><li>Too complicated &amp; too high barrier-to-entry. Because of the way the different transformers interact under the type class resolution mechanism, you need to deal with a very complicated instance structure. You often need to rely on <code>MonadTransControl</code>. You need to have overlapping “pass through” instances. While we have several advanced haskellers who are comfortable with these subjects in principle, in practice the way it fits together can still be quite unintuitive and many modifications have a “trial and error” character. After trying this out for a couple years, we have not seen a sufficient growth in people comfortable with this approach to give us confidence in its long-term viability.</li><li>Difficult to see your entire static (Reader) environment. While this way is harmonious with the recommended practice of running in a monad isomorphic to <code>ReaderT r IO</code>, that correspondence can be difficult to see because that reader environment is spread out over many different transformers. Specifically one needs to <span class="zettel-link-container cf"><span class="zettel-link" title="Zettel: currying"><a href="currying.html">uncurry</a></span></span> the composition of all the <code>run</code> functions to see this environment.</li></ul><h3 id="the-deriving-based-approach">The <em>deriving</em>-based approach</h3><p>Now we’re ready to improve on the two approaches described so far.</p><ul><li>Each type class still gets a trasformer to carry the implementation, but that transformer now <em>only</em> carries the implementation. Each such transformers is <em>nothing but a trivial wrapper</em> – isomorphic to <code>IdentityT</code>. The implementation only gets its resources from the reader environment. This means that the there is no longer any need for the transformers to come with their own natural transformations.</li><li>You once again define a <em>concrete, explicitly named</em> monad for your application and your tests. You write its natural transformation to <code>IO</code>.</li><li>You can still mix and match transformers however you see fit, but now you do that by changing which transformer you derive <code>via</code>.</li></ul><p>I view this approach as essentially taking all the advantages of both the low-tech MTL approach as well as the transformer stack approach. In fact, you might even say this <em>is</em> still the low-tech approach, except now with a very smooth way to plug predefined implementations into your monad!</p><p>To start lets look at the “library code” that provides this default real/test functionality via two trivial transformers:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="co">---------------- Real Implementation Transformer  ----------------</span>
<span class="kw">newtype</span><span class=""> </span><span class="dt">RealPersistDocumentT</span><span class=""> m a </span><span class="ot">=</span><span class=""> </span><span class="dt">RealPersistDocumentT</span><span class=""> {</span><span class="ot"> runRealPersistDocument ::</span><span class=""> m a }</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Functor</span><span class="">, </span><span class="dt">Applicative</span><span class="">, </span><span class="dt">Monad</span><span class="">) via m</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">MonadTrans</span><span class="">) via </span><span class="dt">IdentityT</span>

<span class="kw">data</span><span class=""> </span><span class="dt">ConnPool</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">ConnPool</span>

<span class="kw">instance</span><span class=""> (</span><span class="dt">MonadIO</span><span class=""> m, </span><span class="dt">MonadReader</span><span class=""> env m, </span><span class="dt">HasType</span><span class=""> </span><span class="dt">ConnPool</span><span class=""> env) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> (</span><span class="dt">RealPersistDocumentT</span><span class=""> m) </span><span class="kw">where</span>
<span class="">  persistDocument docId doc </span><span class="ot">=</span><span class=""> lift </span><span class="op">$</span><span class=""> asks (view typed) </span><span class="op">&gt;&gt;=</span><span class=""> \</span><span class="dt">ConnPool</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">pure</span><span class=""> ()</span>
<span class="">  getDocument docId </span><span class="ot">=</span><span class=""> lift </span><span class="op">$</span><span class=""> asks (view typed) </span><span class="op">&gt;&gt;=</span><span class=""> \</span><span class="dt">ConnPool</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">pure</span><span class=""> </span><span class="dt">Nothing</span>
<span class="">  </span><span class="co">-- predent we really did stuff here</span>

<span class="co">---------------- Mock Implementation Transformer  ----------------</span>
<span class="kw">newtype</span><span class=""> </span><span class="dt">MockPersistDocumentT</span><span class=""> m a </span><span class="ot">=</span><span class=""> </span><span class="dt">MockPersistDocumentT</span><span class=""> {</span><span class="ot"> runMockPersistDocumentT ::</span><span class=""> m a }</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Functor</span><span class="">, </span><span class="dt">Applicative</span><span class="">, </span><span class="dt">Monad</span><span class="">) via m</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">MonadTrans</span><span class="">) via </span><span class="dt">IdentityT</span>

<span class="kw">instance</span><span class=""> (</span><span class="dt">Monad</span><span class=""> m, </span><span class="dt">HasType</span><span class=""> (</span><span class="dt">Map</span><span class=""> </span><span class="dt">DocumentId</span><span class=""> </span><span class="dt">Document</span><span class="">) env, </span><span class="dt">MonadState</span><span class=""> env m) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> (</span><span class="dt">MockPersistDocumentT</span><span class=""> m) </span><span class="kw">where</span>
<span class="">  persistDocument docId doc </span><span class="ot">=</span><span class=""> lift </span><span class="op">$</span><span class=""> modify </span><span class="op">$</span><span class=""> over typed </span><span class="op">$</span><span class=""> Map.insert docId doc</span>
<span class="">  getDocument     docId     </span><span class="ot">=</span><span class=""> lift </span><span class="op">$</span><span class=""> gets </span><span class="op">$</span><span class=""> Map.lookup docId </span><span class="op">.</span><span class=""> view typed</span>
</code></pre></div><p>Now that these are implemented, I can easily plug them into my application monad. Best of all somebody else from my company can do this just as easily! Both of us need only add one line to the definition of our monad:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">newtype</span><span class=""> </span><span class="dt">MyApp</span><span class=""> a </span><span class="ot">=</span><span class=""> </span><span class="dt">MyApp</span><span class=""> (</span><span class="dt">AppContext</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">IO</span><span class=""> a)</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Functor</span><span class="">, </span><span class="dt">Applicative</span><span class="">, </span><span class="dt">Monad</span><span class="">, </span><span class="dt">MonadIO</span><span class="">, </span><span class="dt">MonadReader</span><span class=""> </span><span class="dt">AppContext</span><span class="">) via </span><span class="dt">ReaderT</span><span class=""> </span><span class="dt">AppContext</span><span class=""> </span><span class="dt">IO</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> via </span><span class="dt">RealPersistDocumentT</span><span class=""> </span><span class="dt">MyApp</span>
</code></pre></div><p>You can see we are leaning heavily on <code>DerivingVia</code> here. Besides the usual incantation to get all the standard monadic classes, including <code>MonadIO</code> and <code>MonadReader</code>, we also invoke the trivial transformer defined above to claim the desired instance behavior that allows us to work with our database.</p><p>The only requirement for this to work is that our <code>AppContext</code> data type has the required resource, namely in this case a connection pool. This <a href="https://www.youtube.com/watch?v=idU7GdlfP9Q">principled magic</a> is provided by the <code>HasType</code> class from <code>generic-lens</code>.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">AppContext</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">AppContext</span>
<span class="">  {</span><span class="ot"> connection ::</span><span class=""> </span><span class="dt">ConnPool</span>
<span class="">  }</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Show</span><span class="">, </span><span class="dt">Eq</span><span class="">, </span><span class="dt">Generic</span><span class="">)</span>
</code></pre></div><p>This encoding achieves many of the advantages of the transformers approach, by making each individual monadic effect pluggable, but it does so without the host of challenges that come with that approach.</p><p>Similarly we effortlessly plug in the official test implementation to our test monad, with one line.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">newtype</span><span class=""> </span><span class="dt">TestMonad</span><span class=""> a </span><span class="ot">=</span><span class=""> </span><span class="dt">TestMonad</span><span class=""> (</span><span class="dt">State</span><span class=""> </span><span class="dt">MyMockDatabase</span><span class=""> a)</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Functor</span><span class="">, </span><span class="dt">Applicative</span><span class="">, </span><span class="dt">Monad</span><span class="">, </span><span class="dt">MonadState</span><span class=""> </span><span class="dt">MyMockDatabase</span><span class="">) via </span><span class="dt">State</span><span class=""> </span><span class="dt">MyMockDatabase</span>
<span class="">  </span><span class="kw">deriving</span><span class=""> </span><span class="dt">MonadPersistDocument</span><span class=""> via </span><span class="dt">MockPersistDocumentT</span><span class=""> </span><span class="dt">TestMonad</span>
</code></pre></div><p>Now this addressses all the issues we have with the transformer stack way:</p><ul><li>Because we have a named monad with a dedicated <code>run</code> function, its trivial to see what monad we’re running in. There is no undue invitation to scatter different pieces of this transformation into different locations. And the visibility of this <code>run</code> function makes it much easier to see and understand what this monad’s behavior will be. We can be sure that it is indeed <span class="zettel-link-container cf"><span class="zettel-link" title="Zettel: natural transformation"><a href="natural-transformation.html">natural</a></span></span>.</li><li>Newcomers to Haskell or our repo don’t have to worry as much about understanding transformers. They have enough to worry about in understanding monads, and the kind <code>Type -&gt; Type</code>. Of course this new approach is not completely without transformers; they are used to carry instances, but all the transformers are trivial, and there are no transformer <em>stacks</em>. Transformers only ever add one single layer to a concrete monad to control the type class instance, which even if you are advanced is much easier to grasp.</li><li>We don’t have to deal with the complications of <code>MonadTransControl</code>, we can use the much simpler interface of <code>MonadUnliftIO</code>.</li></ul><h2 id="stylistic-questions">Stylistic questions</h2><ul><li>Derive <code>MonadTrans</code> or just use the constructor?</li><li><code>Has</code> or <code>HasType</code>? Since <code>generic-lens</code> is a godsend, we opt for the latter.</li><li>Use <code>newtype</code> deriving strategy or just opt for <code>DerivingVia</code> for everything? I vote for the latter.</li></ul></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2021-09-10">2021-09-10</time></div></div></article><nav class="ui attached segment deemphasized backlinksPane"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" title="2020-08-31T00:18"><a href=".">fieldstrength lab notebook</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc"><span class="zettel-link-container cf"><span class="zettel-link" title="2021-09-10"><a href="an-approach-to-mtl-style.html">An approach to MTL style Haskell</a></span></span></div></li></ul></li></ul></nav><nav class="ui attached segment deemphasized bottomPane"><div><span class="ui basic label zettel-tag" title="See all zettels tagged &#39;draft&#39;">draft</span></div></nav><div class="ui bottom attached icon compact inverted menu teal"><!--replace-start-9--><a class="item" href="." title="Home"><i class="home icon"></i></a><!--replace-end-9--><a class="right item" href="impulse.html" title="Open Impulse"><i class="wave square icon"></i></a></div></div></div><!--replace-end-6--><!--replace-end-3--><!--replace-end-2--><div class="ui center aligned container footer-version"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron 1.9.8.1" /></a></div></div></div></body></html>